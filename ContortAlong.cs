using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using SplineMesh;
using DG.Tweening;

[ExecuteInEditMode]
[RequireComponent(typeof(Spline))]
public class ContortAlong : MonoBehaviour
{
	private Spline spline;
	private MeshBender meshBender;

	[HideInInspector]
	public GameObject generated;
	public bool isSplashed = false;

	public Mesh mesh;
	public Material material;
	public Vector3 rotation;
	public Vector3 scale;

	public Vector3 startScale;
	public Vector3 targetScale;
	[Range(0, 1)] private float lerp;
	[SerializeField] private float scaleDuration = 1f;
	[SerializeField] private Ease scaleEase = Ease.OutBack;
	[SerializeField] private float moveStartDuration = 1f;
	[SerializeField] private float moveSpeed;

	[SerializeField] private ParticleSystem puddle;
	[SerializeField] private ParticleSystem splash;
	[SerializeField] private float effectStartDuration = 1f;

	private void Start()
	{
		isSplashed = false;
		Init(); 
		puddle.gameObject.SetActive(true);
		puddle.Stop();
		splash.gameObject.SetActive(true);
		splash.Stop();
		Invoke("ClosePuddle", 0);
		meshBender.gameObject.SetActive(false);
	}

	private void Update()
	{
		if (generated != null && lerp < 1)
		{
			meshBender.SetInterval(spline, spline.Length * lerp);
			//meshBender.ComputeIfNeeded();
		}
	}

	[ContextMenu("SplashWater")]
	public void SplashWater()
	{
		StopAllCoroutines();

		Init();

		Player.player.CheckCount();

		if (spline.gameObject.activeInHierarchy) StartCoroutine(Splash());
		
	}

	private IEnumerator Splash()
	{
		meshBender.gameObject.SetActive(true);
		GameObject curObj = new GameObject();
		isSplashed = false;
		lerp = 0;
		curObj.transform.localScale = startScale;
		meshBender.Source = meshBender.Source.Scale(startScale);

		curObj.transform.DOScale(targetScale, scaleDuration).SetEase(scaleEase);
		meshBender.Source = meshBender.Source.Scale(curObj.transform.localScale);

		float time = 0;

		//Scale
		while (true)
		{
			yield return new WaitForFixedUpdate();

			time += Time.deltaTime;

			if (time > effectStartDuration && puddle.isStopped)
			{
				puddle.Play();
				splash.Play();
			}

			/*if (lerp > 0.5f)
			{
				isSplashed = true;
			}*/

			if (lerp < 1)
			{
				if (time > moveStartDuration) lerp += moveSpeed * Time.deltaTime;

				if (time < scaleDuration) meshBender.Source = meshBender.Source.Scale(curObj.transform.localScale);
			}

			else break;
		}

		Destroy(curObj);
		puddle.Stop();
		splash.Stop();
		isSplashed = true;
		meshBender.Source = meshBender.Source.Scale(Vector3.one * 0.001f);
		Invoke("ClosePuddle", 0.1f);
	}

	private IEnumerator CloseSplash()
	{
		while (true)
		{
			yield return new WaitForFixedUpdate();
			meshBender.Source = meshBender.Source.Scale(Vector3.one * 0.001f);
		}
	}

	public void RestartObject()
	{
		isSplashed = false;
		Init();
		puddle.gameObject.SetActive(true);
		puddle.Stop();
		splash.gameObject.SetActive(true);
		splash.Stop();
		ClosePuddle();
		meshBender.ComputeIfNeeded();
		meshBender.gameObject.SetActive(false);
		lerp = 0;

		/*isSplashed = true;
		meshBender.Source = meshBender.Source.Scale(Vector3.one * 0.001f);
		
		puddle.Stop();
		splash.Stop();
		ClosePuddle();*/
	}

	private void ClosePuddle()
	{
		puddle.gameObject.SetActive(false);
		//if(meshBender.gameObject.activeInHierarchy) StartCoroutine(CloseSplash());
		//meshBender.gameObject.SetActive(false);
	}

	public void CloseMesh()
	{
		meshBender.Source = meshBender.Source.Scale(Vector3.one * 0.001f);
	}

	public void Init()
	{
		string generatedName = "generated by " + GetType().Name;
		var generatedTranform = transform.Find(generatedName);
		generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
			typeof(MeshFilter),
			typeof(MeshRenderer),
			typeof(MeshBender));

		generated.GetComponent<MeshRenderer>().material = material;

		meshBender = generated.GetComponent<MeshBender>();
		spline = GetComponent<Spline>();

		meshBender.Source = SourceMesh.Build(mesh)
			.Rotate(Quaternion.Euler(rotation))
			.Scale(scale);
		meshBender.Mode = MeshBender.FillingMode.Once;
		meshBender.SetInterval(spline, 0);
	}
}
